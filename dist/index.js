!function(e,t){if("object"==typeof exports&&"object"==typeof module)module.exports=t();else if("function"==typeof define&&define.amd)define([],t);else{var o=t();for(var r in o)("object"==typeof exports?exports:e)[r]=o[r]}}(this,(()=>(()=>{"use strict";var e={d:(t,o)=>{for(var r in o)e.o(o,r)&&!e.o(t,r)&&Object.defineProperty(t,r,{enumerable:!0,get:o[r]})},o:(e,t)=>Object.prototype.hasOwnProperty.call(e,t),r:e=>{"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(e,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(e,"__esModule",{value:!0})}},t={};e.r(t),e.d(t,{RxDBDatabaseConnector:()=>a,RxDBDatabaseTableConnector:()=>s,getRxDBDatabaseConnector:()=>u});const o=require("rxdb"),r=require("rxdb/plugins/storage-dexie");function n(e){if(!e)return{};switch(e.operator){case"==":return{[e.key]:{$eq:e.value}};case"!=":return{[e.key]:{$ne:e.value}};case">":return{[e.key]:{$gt:e.value}};case"<":return{[e.key]:{$lt:e.value}};case"<=":return{[e.key]:{$lte:e.value}};case">=":return{[e.key]:{$gte:e.value}};case"in":return{[e.key]:{$in:e.value}};case"not-in":return{[e.key]:{$nin:e.value}};case"between":return{[e.key]:{$gte:e.value[0],$lte:e.value[1]}};default:throw new Error("Unsupported operator")}}const i=require("uuid");class s{collection;constructor(e){this.collection=e}async get(e){const t=await this.collection.findOne(e).exec();return t?t.toJSON():void 0}async set(e,t){return await this.collection.upsert({...t,id:e}),{...t,id:e}}async add(e){const t=(0,i.v4)();return await this.collection.insert({...e,id:t}),{...e,id:t}}async delete(e){const t=await this.collection.findOne(e).exec();t&&await t.remove()}async clear(){await this.collection.remove()}async list(e){let t=this.collection.find();if(e?.where){const o=n(e.where);t=t.where(o)}if(e?.orderBy){const o={[e.orderBy.key]:e.orderBy.direction};t=t.sort(o)}void 0!==e?.limit&&(t=t.limit(e.limit));let o=await t.exec();return void 0!==e?.offset&&(o=o.slice(e.offset)),o.map((e=>e.toJSON()))}async count(e){let t=this.collection.find();if(e?.where){const o=n(e.where);t=t.where(o)}return(await t.exec()).length}async calculateSize(){return(await this.collection.find().exec()).reduce(((e,t)=>e+new Blob([JSON.stringify(t)]).size),0)}}class a{dbKey;layout;db;collections={};options;constructor(e,t){this.dbKey=e,this.layout=t}async open(){this.db=await(0,o.createRxDatabase)({name:this.dbKey,storage:this.getStorage()});const e=function(e){const t={};for(const[o,r]of Object.entries(e.tables)){const n="id",i=r.indexes?.map((e=>e.keyPath))||[],s={};for(const e of i)s[e]={type:"string"};s[n]={type:"string"};const a={title:o,version:e.version,type:"object",properties:s,primaryKey:n,indexes:i};t[o]=a}return t}(this.layout),t={};Object.entries(e).forEach((([e,o])=>{t[e]={schema:o}}));const r=await this.db.addCollections(t);Object.keys(e).forEach((e=>{this.collections[e]=r[e]}))}async close(){await(this.db?.destroy()),this.collections={}}hasTable(e){return!!this.collections[e]}createTable(e){if(!this.hasTable(e))throw new Error(`Table ${e} is not predefined and cannot be created dynamically.`)}getTableConnector(e){if(!this.hasTable(e))throw new Error(`Table ${e} does not exist`);return new s(this.collections[e])}getStorage(){return this.options?.storage||(this.options={storage:(0,r.getRxStorageDexie)()}),this.options.storage}}const c=require("rxdb/plugins/migration-schema"),l=require("rxdb/plugins/query-builder");function u(e){return e?class extends a{constructor(t,o){super(t,o),e&&Object.assign(this,e)}}:a}return(0,o.addRxPlugin)(l.RxDBQueryBuilderPlugin),(0,o.addRxPlugin)(c.RxDBMigrationPlugin),t})()));